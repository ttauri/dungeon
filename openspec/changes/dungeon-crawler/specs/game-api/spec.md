## ADDED Requirements

### Requirement: REST API for game control
The game SHALL expose a REST API when started in API mode (`dungeon --api --port 8080`). The API serves JSON and allows full game control without a terminal.

#### Scenario: Start API server
- **WHEN** the binary is run with `--api --port 8080`
- **THEN** an HTTP server starts on port 8080 serving the game API, with no TUI rendered

### Requirement: New game endpoint
POST /api/v1/game/new SHALL create a new game. Request body includes character name (string), class (fighter|rogue|cleric|wizard), and optional seed (int64). Response includes the initial game state and the assigned seed.

#### Scenario: Create new game
- **WHEN** POST /api/v1/game/new with `{"name":"Kael","class":"fighter","seed":42}`
- **THEN** response is 201 with full initial game state including floor 1 map, character stats, and seed 42

#### Scenario: Create game without seed
- **WHEN** POST /api/v1/game/new with `{"name":"Kael","class":"wizard"}`
- **THEN** response includes a randomly generated seed in the state for reproducibility

### Requirement: Game state endpoint
GET /api/v1/state SHALL return the current observable game state as JSON. The state includes: turn number, floor, position, facing direction, visible tiles (FOV), explored map, player stats, inventory, active conditions, visible entities (monsters/items with relative positions), and the last N log entries.

#### Scenario: State retrieval
- **WHEN** GET /api/v1/state is called mid-game
- **THEN** response is 200 with JSON containing all observable state fields, respecting fog of war

### Requirement: Action endpoint
POST /api/v1/action SHALL submit a player action. The request body includes an action type and action-specific parameters. The response includes the action result, updated game state, and new log entries generated by the action.

#### Scenario: Move action
- **WHEN** POST /api/v1/action with `{"action":"move","direction":"forward"}`
- **THEN** response includes success/failure, the updated state after player and monster turns resolve, and log entries

#### Scenario: Attack action
- **WHEN** POST /api/v1/action with `{"action":"attack"}`
- **THEN** response includes attack roll details, damage if hit, monster response, and updated state

#### Scenario: Invalid action
- **WHEN** POST /api/v1/action with `{"action":"move","direction":"forward"}` but a wall is ahead
- **THEN** response is 400 with error message "Cannot move forward: wall", turn does not advance

### Requirement: Game log endpoint
GET /api/v1/log SHALL return recent game log entries. Accepts optional query parameter `limit` (default 20, max 100). Returns an array of log entry objects with turn number, timestamp, and message text.

#### Scenario: Log retrieval
- **WHEN** GET /api/v1/log?limit=5
- **THEN** response is 200 with the 5 most recent log entries in chronological order

### Requirement: Game info endpoint
GET /api/v1/game/info SHALL return metadata about the current game: seed, character name, class, current floor, turn count, game status (playing|dead|victory), and available actions from current state.

#### Scenario: Available actions
- **WHEN** GET /api/v1/game/info is called while an Orc is adjacent
- **THEN** the available_actions list includes "attack", "cast_spell", "use_item", "turn_left", "turn_right", "move_backward"

### Requirement: WebSocket watch endpoint
GET /api/v1/ws/watch SHALL upgrade to a WebSocket connection that streams game state after every turn. Each message is a JSON object with the action taken, the result, and the new state. This enables real-time observation of agent play.

#### Scenario: Watch agent play
- **WHEN** a WebSocket client connects to /ws/watch and an agent submits actions via POST /action
- **THEN** the WebSocket client receives a JSON message after each turn with the action, result, and new state

### Requirement: API error format
All API errors SHALL return JSON with fields: `error` (string, human-readable message), `code` (string, machine-readable error code), and HTTP status code. Common codes: `invalid_action`, `game_over`, `no_game`, `bad_request`.

#### Scenario: No active game
- **WHEN** GET /api/v1/state is called before POST /game/new
- **THEN** response is 404 with `{"error":"No active game","code":"no_game"}`
