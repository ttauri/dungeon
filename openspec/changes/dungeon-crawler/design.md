## Context

Greenfield Go project — no existing code. The repo (`dungeon`) is empty aside from a README. We're building a first-person grid-based dungeon crawler inspired by Eye of the Beholder (1991), with a terminal UI and an API for AI agent play.

The game is single-character (not party-based), uses simplified D&D 5e mechanics, and targets 12 procedurally generated dungeon floors with hand-crafted vault rooms. The dual human/agent interface drives a hard architectural requirement: the game engine must be fully decoupled from presentation.

Constraints:
- Go 1.22+ (single binary, no CGO)
- Terminal-only rendering (no graphics libraries)
- Turn-based (no real-time concerns in the engine)
- Seeded RNG for reproducible runs

## Goals / Non-Goals

**Goals:**
- Playable dungeon crawl with 4 classes, 36 monsters, 12 floors, and meaningful tactical decisions
- Retro ASCII aesthetic that feels authentic to the era
- Clean engine/UI separation so the same game logic serves both TUI and API
- API complete enough for an LLM agent to play without human assistance
- Seeded procgen for reproducible balance testing

**Non-Goals:**
- Multiplayer or networked play
- Save/load to disk (can add later, not MVP)
- Sound or music
- Mouse input
- Mobile or web frontend
- Mod support or scripting
- Persistent progression between runs

## Decisions

### 1. Package structure — Layered engine with thin adapters

```
dungeon/
├── cmd/dungeon/         main.go — CLI entry point
├── engine/              Game loop, turn processing, state transitions
├── world/               Map generation, tiles, vaults, floor templates
├── combat/              D20 system, damage calc, conditions, initiative
├── entity/
│   ├── player/          Character, classes, leveling, inventory
│   └── monster/         Monster definitions, AI behaviors
├── magic/               Spell definitions, effects, slot management
├── item/                Item types, loot tables, equipment
├── fov/                 Field of vision / line of sight calculation
├── tui/                 Bubbletea terminal interface
│   ├── viewport/        First-person ASCII renderer
│   ├── minimap/         Fog-of-war automap
│   ├── stats/           Character stats panel
│   ├── log/             Scrollable game log
│   └── input/           Key bindings and input routing
├── api/                 HTTP + WebSocket server
└── data/                Static data (monster stats, items, spells as Go structs)
```

**Rationale**: The engine package owns the `Game` struct and exposes a `Game.Do(action Action) Result` method. Both TUI and API are thin adapters calling this same interface. No game logic in presentation code.

**Alternative considered**: Single flat package. Rejected — 36 monster types and 4 classes create enough complexity that separation pays for itself immediately.

### 2. TUI framework — Bubbletea + Lipgloss

Bubbletea provides the Elm-architecture model (Model/Update/View) which maps perfectly to a turn-based game: player action → engine update → re-render. Lipgloss handles styling (borders, colors, alignment).

**Alternative considered**: Tcell (raw terminal). More control but much more boilerplate for layout composition. Bubbletea's component model lets us build viewport, minimap, stats, and log as independent sub-models.

### 3. First-person renderer — Pre-computed depth layers

The viewport renders 3 depth layers (near, mid, far) using pre-drawn ASCII templates for each wall/door/corridor configuration. At each depth, we composite:
1. Base corridor shape (wall patterns for left/right/front)
2. Door overlays (if door exists at that depth)
3. Monster/item sprites (ASCII art scaled to depth)

```
Depth 0 (near):  Full-size monster art, detailed walls
Depth 1 (mid):   Medium monster art, corridor narrowing
Depth 2 (far):   Small monster silhouette, tight corridor
```

Each facing direction × wall configuration is a template lookup, not a runtime calculation. This keeps rendering fast and deterministic.

**Alternative considered**: True ASCII raycasting (Wolfenstein-style). Cooler but much harder to show discrete game objects (doors, monsters, items) clearly. The depth-layer approach is more faithful to EoB and easier to populate with content.

### 4. Map generation — BSP tree + vault injection

Each floor is a 30×30 grid generated by:
1. **BSP partitioning** — recursively split the grid into rooms
2. **Corridor carving** — connect rooms via L-shaped corridors
3. **Vault injection** — replace 1-2 random rooms with hand-crafted vaults (pre-designed encounters, puzzles, set-pieces)
4. **Feature placement** — distribute stairs, doors, traps, secrets, treasure based on floor depth
5. **Monster spawning** — populate rooms from the tier-appropriate monster pool

Floor 12 (The Throne) skips procgen entirely — it's a hand-crafted boss level.

Seeded via Go's `math/rand/v2` with a user-provided or random seed. Same seed = same dungeon.

**Alternative considered**: Cellular automata (more organic caves). Doesn't fit the EoB aesthetic of structured rooms and corridors. BSP gives us the architectural dungeon feel.

### 5. Combat — Simplified D&D with d20 core

```
Turn order:    Initiative (d20 + DEX mod), higher goes first
Attack:        d20 + ability mod + proficiency ≥ target AC → hit
Damage:        Weapon die + ability mod
Saving throw:  d20 + ability mod ≥ DC
```

No bonus actions, reactions, or opportunity attacks. One action per turn: attack, cast spell, use item, move, or interact. This keeps combat fast while preserving the D&D feel of "roll to hit, roll damage."

Conditions supported: poisoned, stunned, paralyzed, frightened, slowed, blinded. Each has a clear mechanical effect and a duration in turns.

### 6. Monster AI — Behavior tags, not behavior trees

Each monster type has a set of behavior tags that the combat AI evaluates:

```go
type MonsterDef struct {
    // ...
    Behaviors []Behavior  // e.g., Ambusher, Charger, Caster, Fleeing, Pack
}
```

Tags compose: a Goblin is `[Ambusher, Fleeing]` (surprise attack, runs when hurt). A Lich is `[Caster, Summoner]`. The AI loop checks tags in priority order to decide the action. Simple, extensible, and each monster feels different without per-monster code.

**Alternative considered**: Full behavior trees. Overkill for turn-based single-target combat. Tags give us 80% of the feel at 20% of the complexity.

### 7. API design — REST + WebSocket

```
GET  /api/v1/state          Full observable game state (JSON)
POST /api/v1/action         Submit player action, returns result + new state
GET  /api/v1/log            Recent N game log entries
GET  /api/v1/ws/watch       WebSocket — streams state diffs on each turn
POST /api/v1/game/new       Start new game (class, seed, name)
GET  /api/v1/game/info      Current game metadata
```

State response includes only what the character can observe (fog of war applies). The agent doesn't get omniscient map data.

WebSocket `/watch` pushes state after every turn — this is how you watch an agent play in real-time.

### 8. Data format — Go structs, not YAML/JSON files

Monster stats, items, and spells are defined as Go structs with compile-time initialization. No file parsing, no data directory, no deserialization bugs. The binary is fully self-contained.

```go
var Monsters = map[MonsterID]MonsterDef{
    GiantRat: {Name: "Giant Rat", HP: 7, AC: 12, ...},
    Goblin:   {Name: "Goblin", HP: 12, AC: 13, ...},
}
```

**Alternative considered**: YAML/JSON data files. Adds complexity (embedding, parsing, validation) for no real benefit — we're not shipping a mod-friendly game.

## Risks / Trade-offs

- **[ASCII viewport complexity]** → The first-person renderer is the most visually ambitious part. Mitigate by building a small set of wall templates first and validating the look before drawing all 36 monster sprites. Start with 3-4 monsters, prove the renderer, then expand.

- **[36 monster types is a lot of content]** → Each needs stats, behavior tags, and ASCII art. Mitigate by defining the stat/behavior system generically, then batch-create monsters tier by tier. ASCII art can start minimal (2-3 line silhouettes) and be refined.

- **[Balance across 4 classes × 12 floors]** → This is exactly what the agent API is for. Seed-based runs let us A/B test balance changes. But initial tuning will be rough — accept that and iterate.

- **[Bubbletea layout at this complexity]** → 4 panels (viewport, minimap, stats, log) in one terminal is ambitious. Mitigate by using lipgloss.JoinHorizontal/Vertical for layout and testing at common terminal sizes (80×24 minimum, 120×40 target).

- **[No save/load in MVP]** → A full 12-floor run could take 1-2 hours. If the terminal crashes, progress is lost. Acceptable for MVP since agent runs are automated and humans can restart. Add save/load as a fast-follow.
